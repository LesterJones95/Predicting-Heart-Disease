# Run locally on your cpu (test if everything works)
## Secure notebook [optional]
#### Insecure connection to Jupyter Notebook
Although _I_ run this notebook on a localhost at home and therefore not exposed to the public internet and therefore malicious actors are unlikely to access this notebook, I like to copy/paste this secure setup. <br/>

#### Secure connection to Jupyter Notebook
However, it is good to follow through. <br/>
Hashing your password means that a hash of your password is stored. However without SSL certificates your password is still readable during a man in the middle attack because it is send with HTTP to the server. <br/> 
Using a password anyways is still easier than copying the authentication token that is generated by Jupyter each time the docker container starts. <br/>
Securing traffic with certificates means that your data (password or authentication token) is send encrypted over the network. 

### Create hashed password [optional]
Optionally you can create your own password for your Jupyter notebook by following the steps below: <br/>
If you choose not to, than a random security token will be generated each time you start the docker container.

```bash
    # in root folder
    PASSWORD=mypassword #change this password
    SALT=$(openssl rand -hex 12)

    # Create salted password and hash it
    SALTED="${PASSWORD}${SALT}"
    HASH=$(echo -n "$SALTED" | openssl dgst -sha1 -binary | xxd -p -c 256)

    # Format as Jupyter expects: sha1:salt:hash
    echo "JUPYTER_PASSWORD_HASH="sha1:${SALT}:${HASH}"" > ./jupyter-config/.env
```
### Creating SSL certificates [optional] (recommended)
With certificates you send data encrypted over the internet (HTTPS) and not in plain text (HTTP). <br/>
Adding self-signed certificates to your Jupyter Notebook instance ensures that your authentication password or token is encrypted before sending it over the internet. <br/>
Since these certificates are self signed your browser will not recognize them and still give a warning that your data might not be safe. <br/> 
You know though that you can trust the server and it's certificate and continue to the webpage. <br/>
**Important** the ```jupyter-config/certs/``` directory needs to exist for the build to run, but it can stay empty.
```bash
    # in root folder
    JUPYTER_DIR="./jupyter-config/certs"
    CERT_FILE="${JUPYTER_DIR}/jupyter_cert.pem"
    KEY_FILE="${JUPYTER_DIR}/jupyter_key.key"

    mkdir -p ${JUPYTER_DIR}
    openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout "${KEY_FILE}" -out "${CERT_FILE}" -subj "//C=NL/ST=State/L=City/O=Organization/CN=localhost"
```
## Running the container 
#### Run and build container with docker-compose (recommended)
```bash
    # from root where docker-compose file is:

    PROFILE=local-default #local-kaggle-datasets 
    docker compose --profile ${PROFILE} build
    docker compose --profile ${PROFILE} up

    # if port 8888 is busy
    EXTERNAL_PORT=9999 docker compose --profile ${PROFILE} up 
```

### Test Locally
After running the docker compose up, logs will be generated, somewhere a logline will look like: ```http(s)://localhost:8888```. <br/>
Follow that link, and you will find your notebook environment there. <br/> 
Note your browser will probably give a warning that it does not "trust" your self-signed certificate if you configured SSL, that is not a problem because **you** trust it (hopefully). So proceed to the webpage.<br/>
Run the code and confirm that a (new) 'submission_cpu.csv' file is created in the root of the directory.
